---
title: "Каналы в Go"
publishdate: "2021-03-05"
lastmod: "2021-03-05"
summary: "golang"
categories:
  - "golang"
tags:
  - "go channels"
  - "book notes"
---

{{<the_go_pl_notes_ru >}}

# Канал

Канал - средство связи между горутинами. Каналы передают значения одного типа (тип канала).

Для создания канала мы используем встроенную функцию make
```
ch := make(chan int) // ch имеет тип 'chan int'
```

Канал - ссылочный тип
```
	var nilChannel chan int
	leftmost := make(chan int)
	right := leftmost
	left := leftmost
	fmt.Printf("%+v\r\n", right)
	fmt.Printf("%+v\r\n", left)
	fmt.Printf("%+v\r\n", right == left)
	fmt.Printf("%+v\r\n", leftmost == nil)
	fmt.Printf("%+v\r\n", nilChannel == nil)
	go func() {
		right  <- 1
	}()
	fmt.Println(<-left)
```
вывод
```
0xc000094060
0xc000094060
true
false
true
1

```
Нулевое значение канала - nil.

Канал поддерживает 2 типа операций - запись и чтение:
```
ch <- x // запись
x = <- ch // чтение
<-ch // чтение без использования результата
```

Каналы поддерживают опeрацию закрытия
```
close(ch)
```
после этого, любая попытка записи в канал вызовет панику. Операции получения, примененные к закрытому каналу, приводят к получению значений, которые были отправлены ранее, до тех пор, пока неполученных значений не останется; любые дальнейшие попытки получить значения приводят к немедленному завершению операции и возврату нулевого значения типа элемента канала.

Нельзя закрыть канал для чтения. Попытка закрыть канал только для получения приводит к ошибке времени компиляции.

Канал, созданный с помощью простого вызова make называется небуферизованным каналом, но make принимает необязательный второй аргумент, целое значение, которое называется емкостью канала. Если емкость канала ненулевая - make создает буферизованный канал.
Небуферизованные каналы (в отличие от буферизованных) поддерживают синхронизацию между горутинами.
```
ch = make(chan int) // Небуферизованный канал
ch = make(chan int, 0) // Небуферизованный канал
ch = make(chan int, 3) // Буферизованный канал с емкостью 3
```

# Небуферизованные каналы

Операция отправления в небуферизованный канал блокирует go-подпрограмму до
тех пор, пока другая go-подпрограмма не выполнит соответствующее получение из
того же канала, после чего значение становится переданным, и обе go-подпрограммы
продолжаются. И наоборот, если первой сделана попытка выполнить операцию получения, принимающая go-подпрограмма блокируется до тех пор, пока другая go-
подпрограмма не выполнит отправление значения в тот же канал.
Связь по небуферизованному каналу приводит к синхронизации операций отправления и получения. По этой причине небуферизованные каналы иногда называют
синхронными. Когда значение отправляется в небуферизованный канал, получение
значения предшествует продолжению работы отправляющей go-подпрограммы.

Не существует способа непосредственно проверить, закрыт ли канал, но есть вариант операции получения, которая возвращает два результата: полученный из канала элемент и логическое значение, условно называемое ok, которое равно true при успешном получении значения и false — при получении из закрытого и опустошенного канала.
```
go func() {
    for {
        х, ok := <-naturals
        if !ok {
            break // Канал закрыт и опустошен
        }
        squares <- х * х
    }
    close(squares)
}()
```
альтернативный вариант - цикл по диапазону
```
func main() {
	naturals := make(chan int)
	squares := make(chan int)

	go func() {
		for x := 0; x < 100; x++ {
			naturals <- x
		}
		close(naturals)
	}()

	go func () {
		for x := range naturals {
			squares <- x * x
		}
		close ( squares )
	} ()

	for x := range squares {
		fmt.Println(x)
	}
}
```
Вам не нужно закрывать каждый канал по завершении работы с ним. Необходимо
закрывать каналы тогда, когда важно сообщить принимающей go-подпрограмме, что
все данные уже отправлены. Ресурсы канала, который сборщик мусора определяет
как недоступный, будут освобождены в любом случае, независимо от того, закрыт ли
он. Не путайте это с операцией закрытия открытых файлов; вызывать метод close
важно для каждого файла, работа с которым завершена. Попытка закрыть уже закрытый канал вызывает аварийную ситуацию, так же как
и закрытие нулевого канала.

# Однонаправленные каналы

Нарушения применения каналов обнаруживаются во время компиляции. Преобразования двунаправленных каналов в однонаправленные разрешается в любом присваивании. Однако обратное не верно.

# Буферизованные каналы

Буферизованный канал имеет очередь элементов. Максимальный размер очереди определяется при создании канала с помощью аргумента емкости функции make. Создаем канал емкостью 3
```
ch = make(chan string, 3)
```
Операция отправления в буферизованный канал вставляет отправляемый элемент
в конец очереди, а операция получения удаляет первый элемент из очереди. Если канал заполнен, операция отправления блокирует свою go-подпрограмму до тех пор, пока другая go-подпрограмма не освободит место, получив данные из канала. И наоборот, если канал пуст, операция получения блокирует go-подпрограмму до того момента, пока в канал не будет послано значение из другой go-подпрограммы.

Узнать размер буфера
```
cap(ch) //3
```

При применении к каналу встроенная функция len возвращает количество элементов, находящихся в настоящее время в буфере. Поскольку в параллельной программе эта информация, скорее всего, окажется устаревшей сразу по получении, ее применение ограничено, но она может оказаться полезной для оптимизации производительности или при отладке.

Новички иногда соблазняются простым синтаксисом и используют буферизованные каналы в пределах одной go-подпрограммы в качестве очереди, но это ошибка. Каналы глубоко связаны с планированием go-подпрограмм, и без другой go-подпрограммы, получающей данные из канала, отправитель — да, пожалуй, вся программа в целом — рискует быть навсегда заблокированным. Если все, что вам нужно, — это простая очередь, воспользуйтесь срезом.

# Утечка горутин

```
func mirroredQuery() string {
	responses := make(chan string, 3)
	go func() { responses <-request("asia.gopl.io") }()
	go func() { responses <-request("europe.gopl.io") }()
	go func() { responses <-request("americas.gopl.io") }()
	return <- responses // Возврат самого быстрого ответа
}
func request(host string)(res string) { ... }
```
Если бы мы использовали канал без буферизации, две более медленные go-подпрограммы были бы заблокированы при попытках отправить свои ответы в канал, из которого никто никогда не пытался бы считывать данные. Эта ситуация, которая называется утечкой go-подпрограмм, была бы ошибкой. В отличие от переменных, потерянные go-подпрограммы не собираются сборщиком мусора автоматически, поэтому важно гарантировать, что go-подпрограммы должны прекратиться сами, когда они больше не нужны.

# Паттерны

## Параллельные циклы

Hе существует непосредственного способа дождаться завершения go-подпрограммы, но мы можем изменить внутреннюю go-подпрограмму таким образом, чтобы она сообщала о своем завершении внешней go-подпрограмме, отправляя событие в общий канал.

```
// makeThumbnails3 makes thumbnails of the specified files in parallel.
func makeThumbnails3(filenames []string) {
	ch := make(chan struct{})
	for _, f := range filenames {
		go func(f string) {
			thumbnail.ImageFile(f) // NOTE: ignoring errors
			ch <- struct{}{}
		}(f)
	}

	// Wait for goroutines to complete.
	for range filenames {
		<-ch
	}
}
```

Будьте внимательны - f надо передавать как параметр функции, а не как внешнюю переменную
```
for f := range filenames {
    go func() {
    thumbnail.ImageFile(f) // Примечание: неправильно!
    // ...
    } ()
}
```
так как цикл завершится до того, как f будет передано ImageFile. В результате f будет не тем, что мы ожидаем получить.

```
func makeThumbnails4(filenames []string) error {
    errors := make(chan error)
    for f := range filenames {
        go func(f string) {
            err := thumbnail.ImageFile(f)
            errors <- err
        }(f)
    }
    for range filenames {
        if err := <-errors; err != nil {
            return err // Примечание: неверно: утечка go-подпрограмм!
        }
    }
    return nil
}
```
В этой функции содержится тонкая ошибка. Встретив первую ненулевую ошибку, она возвращает ее вызывающей функции, не позволяя go-подпрограмме опустошить канал errors. В результате, каждая оставшаяся работающая go-подпрограмма будет навсегда заблокирована, если попытается отправить значение в этот канал, и никогда не завершится. Эта ситуация, утечка go-подпрограмм (раздел 8.4.4), может привести к остановке всей программы или нехватке памяти. Самым простым решением является использование буферизованного канала с достаточной емкостью, который не будет блокировать рабочие go-подпрограммы при отправке сообщений. Альтернативное решение заключается в создании еще одной go-подпрограммы для опустошения канала, в то время как основная go-подпрограмма без промедления возвращает первую ошибку.

# sync.WaitGroup

https://golang.org/pkg/sync/#WaitGroup

Простое средство синхронизации горутин. Вызов Wait будет блокировать выполнение, пока количество вызовов Done() не будет равно добавленным в группу горутинам посредством Add(1).

```
func main(){
	filenames := make(chan int)
	var wg sync.WaitGroup
	for i := 0; i < 3; i++ {
		wg.Add(1)
		go func(j int){
			defer wg.Done()
			fmt.Println("sending", j)
			filenames <- j
			fmt.Println("sent", j)
		}(i)
	}
	go func(){
		wg.Wait()
		close(filenames)
		fmt.Println("chanel closed")
	}()
	res := makeThumbnails6(filenames)
	fmt.Println("RES", res)
}

func makeThumbnails6(filenames <-chan int) int {
	var total int
	for v := range filenames {
		fmt.Println("got", v)
		total += v
	}
	fmt.Println("no more elements")
	return total
} 
```
вывод
```
sending 0
sending 2
sending 1
got 0
got 2
got 1
sent 0
sent 2
sent 1
chanel closed
no more elements
RES 3
```

Конец статьи.