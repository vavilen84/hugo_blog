---
title: "Вычисление Big O для начинающих"
publishdate: "2021-04-21"
lastmod: "2021-04-21"
summary: "go"
categories:
- "algorithms"
tags:
- "algorithms"
- "Big O"
---

Источники:

- "Оценка сложности алгоритмов" https://www.youtube.com/watch?v=kwmQwGbAh28
- "Оценка сложности алгоритма" https://www.youtube.com/watch?v=ZRdOb4yR0kk
- "Структуры данных для самых маленьких" https://habr.com/ru/post/310794/
- "Полный курс: оценка сложности алгоритмов. Нотация Big O" https://www.udemy.com/course/big-o-ru/ (Автор статьи рекомендует данный курс к ознакомлению)
- [wikipedia "Временная сложность алгоритма"](https://ru.wikipedia.org/wiki/%D0%92%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0)

Большое "O" (Big O) - зависимость роста времени выполнения(временная сложность)/расхода памяти(пространственная сложность) 
алгоритма от роста входных данных.

## Вычисление сложности: неважная сложность, упрощение

При вычислении наихудшего сценария может не учитываться сложности, которые растут медленнее. Например, если алгоритм имеет квадратичную 
и линейную сложности O(N{{< exp >}}2{{< /exp >}} + N), то линейная сложность может не учитываться, т.к. квадратичная 
сложность растет быстрее. В результате, сложность будет O(N{{< exp >}}2{{< /exp >}}). 

Но, если, скажем, сложность будет O(N{{< exp >}}2{{< /exp >}} + B), при том, что мы не знаем B - отбросить его мы не 
можем. Соответственно, сложность будет O(N{{< exp >}}2{{< /exp >}} + B).

Если у нас есть сложность O(2{{< exp >}}n{{< /exp >}} + N{{< exp >}}100{{< /exp >}}) - то мы можем упростить до 
O(2{{< exp >}}n{{< /exp >}}), т.к. экспоненциальная сложность растет быстрее, чем степенная.

## Сложение сложностей

```
func sum(a, b []int) (res int) {
	for k := range a { // N
		res += a[k] // 1
	}
	for k := range b { // K
		res += b[k] // 1
	}
	return
}
```
сложностью данного алгоритма будет: O((N * 1) + (K * 1)) = O(N+K)

## Умножение сложностей
```
func multi(a [][]int) (res int) {
	for v := range a { // N
		for h := range a[v] { // L
			res += a[v][h] // 1
		}
	}
	return
}
```
сложностью данного алгоритма будет: O(N * (L * 1)) = O(N * L)

## Сложности

{{<table "table table-bordered">}}
| Сложность | Обозначение | Результативность |
|-----------|-------------|--------------|
| Константная   | O(1)   | отлично   |
| Логарифмическая   | O(log N)    | отлично   |
| Сублинейная   | O({{< html >}}&radic;{{< /html >}}N)   | отлично   |
| Линейная   | O(N)   | хорошо  |
| Линейно-логарифмическая   | O(N log N)   | приемлемо   |
| Квадратичная   | O(N{{< exp >}}2{{< /exp >}})   | плохо  |
| Кубическая   | O(N{{< exp >}}3{{< /exp >}})  | плохо   |
| Полиномиальная   | O(N^{{< exp >}}3{{< /exp >}})  | плохо   |
| Экспоненциальная   | O(2^{{< exp >}}n{{< /exp >}})   | плохо   |
| Факториальная  | O(N!)  | плохо  |
{{</table>}}

![](/posts/big_o_graph.png)

## Константная сложность - O(1)

```
func sum(a, b int) int {
    return a + b // 1
}
```

данная функция всегда будет выполнять только одну операцию сложения независимо от значения a и b. Следовательно, большое
О - константное.

## Линейная сложность - O(N)

```
func findOffset(needle int, haystack []int) int {
	for k := range haystack // N {
		if haystack[k] == needle { // 1
			return k // 1
		}
	}
	return -1 // 1
}
```
сложность будет: O((N * 1) + 1) = O(N). Количество итераций цикла внутри функции findOffset линейно зависят от 
количества элементов в haystack:
- при длинне haystack равной 2, наибольшее возможное количество итераций будет равно 2
- при длинне haystack равной 10, наибольшее возможное количество итераций будет равно 10
и т.д.

Рассмотрим рекурсивную функцию
```
func sum(n int) int {
	if n == 1 { // 1
		return n  // 1
	}
	return n + sum(n-1) // 1 + N
}
```

временная сложность будет: O(1 + (1 + N)) или просто линейная O(N). Количество операций рекурсивного вызова будет расти 
пропорционально величине n.

## Квадратичная O(N{{< exp >}}2{{< /exp >}}) и кубическая O(N{{< exp >}}3{{< /exp >}}) сложности

```
for keyA := range a { // N
    for keyB := range a { // N
        ...
    }
}
```

вложенный цикл имеет квадратичную сложность O(N * N) = O(N{{< exp >}}2{{< /exp >}}). Два вложенных цикла - кубическую O(N * N * N) = O(N{{< exp >}}3{{< /exp >}}):

```
for keyA := range a { // N
    for keyB := range a { // N
        for keyC := range a { // N
            ...
        }
    }
}
```

## Логарифмическая сложность

```
func iterate(a []int) (res int) {
	for {
		...
		if len(a) == 1 {
			break
		}
		a = a[len(a)/2:]
	}
	return
}
```
Для алгоритма, где на каждой итерации берется половина элементов - сложность будет включать O(log N) 
. Например, алгоритм бинарного поиска.

## Вычисление временной сложности

Предположим, алгоритм имеет два цикла и одну константную по времени операцию

```
func algo(n []int) int {
    res := 0
    for k := range n { // N
        res += n[k] // 1
    }
    for k := range n { // N
        res += n[k] // 1
    }
    res += 1 // 1
    return res
}
```
В результате мы имеем O((N * 1) + (N * 1) + 1) = O(N + N) или просто O(N).

Пример ниже имеет сложность O(1 + (N * 1) + (N * 1) + 1 + (N * (N + 1))) = O(N + N + N{{< exp >}}2{{< /exp >}}) или просто  O(N{{< exp >}}2{{< /exp >}})
```
func algo(n []int) int {
    res := 0 // 1
    for k := range n { N
        res += n[k] // 1
    }
    for k := range n { // N
        res += n[k] // 1
    }
    res += 1 // 1
    for k := range n { // N
		for c := range n { // N
			res += n[k] + n[c] // 1
		}
	}
    return res // 1
}
```

## Вычисление пространственной сложности

Алгоритм поиска максимума будет иметь константную O(1) пространственную сложность, так как расход памяти всегда будет
детерминирован (память выделяется только один раз):
```
func max(n []int) int {
	res := math.MinInt64 // 1
	for k := range n {
		if res < n[k] {
			res = a
		}
	}
	return res
}
```

Алгоритм слияния срезов будет иметь сложность O(A + B), т.к. для результирующего среза будет
выделен объем памяти пропорциональный длинне входных срезов:
```
func merge(a, b []int) []int {
	res := make([]int, len(a)+len(b))
	for k := range a {
		res[k] = a[k]
	}
	for k := range b {
		res[len(a)+k] = b[k]
	}
	return res
}
```

## Другие примеры вычисления сложности

### Циклы

Дано: функция содержит цикл и вызов другой функции:
```
func sumSequence(n int) int {
	res := 0 // 1
	for i := 0; i < n; i++ {  // N
		res += sum(i, i+1) // 1
	}
	return res
}

func sum(a, b int) int {
	return a + b // 1
}
```
Временная сложность: O(1 + (N * 1)) = O(N); пространственная сложность - константная O(1).

Давайте сравним две функции
```
func minMax(n []int) (min, max int) {
	min = math.MaxInt64 
	max = math.MinInt64
	for k := range n { // N
		if n[k] < min { // 1
			min = n[k] // 1
		}
		if n[k] > max {
			max = n[k] // 1
		}
	}
	return
}
```
сложность O(N * (1 + 1)) или просто O(N)
```
func minMax(n []int) (min, max int) {
	min = math.MaxInt64
	max = math.MinInt64
	for k := range n { // N
		if n[k] < min { // 1
			min = n[k] // 1
		}
	}
	for k := range n { // N
		if n[k] > max { // 1
			max = n[k] // 1
		}
	}
	return
}
```
сложность O((N * (1 * 1)) + (N * (1 * 1))) или просто O(N). Пространственная сложность - константная.

Рассмотрим данные вложенные циклы
```
for i := 0; i < N; i++ { // N
    for j := 0; j < N; j++ { // N
        foo()
    }
}
```
```
for i := 0; i < N; i++ { // N
    for j := i; j < N; j++ { // N
        foo()
    }
}
```
из иллюстрации ниже мы видим, что во втором примере вложенный цикл уменьшается ровно на половину
![](/posts/big_o_nested_loops.png)
соответственно, для второго примера сложность будет O(N{{< exp >}}2{{< /exp >}}/2) или просто квадратичная O(N{{< exp >}}2{{< /exp >}})

Пример ниже не будет иметь кубическую сложность, т.к. сложность второго вложенного цикла - константа "100"
```
for i := 0; i < N; i++ { // N
    for j := 0; j < N; j++ { // N
        for c := 0; с < 100; j++ { // константа 100
            foo()
        }
    }
}
```

Пример ниже будет иметь сложность O(A*B), т.к. a и b различны
```
func foo(a, b []int) {
    for i := 0; i < a; i++ { // A  
        for j := 0; j < b; j++ { // B 
            ...
        }
    }
}
```

Пример ниже будет иметь сложность O(N/2) или просто O(N)
```
func foo(a []int){
    for i := 0; i < (len(a)/2); i++ {
        ...
    }
}
```

### Строки

Алгоритм сравнения строк посимвольно будет иметь линейную временную сложность:
```

func compareStrings(s1, s2 string) int {
	if len(s1) > len(s2) { // 1
		return 1
	}
	if len(s1) < len(s2) {  // 1
		return -1
	}
	for i := 0; i < len(s1); i++ { // N 
		if s1[i] > s2[i] { // 1
			return 1
		}
		if s1[i] < s2[i] { // 1
			return -1
		}
	}
	return 0 // 1
}
```

Алгоритм конкатенации строк будет иметь временную и пространственную сложности O(N + K)
```
func concatenateString(s1, s2 string) string {
	result := make([]byte, len(s1)+len(s2))
	for k := range []byte(s1) { // N
		result[k] += s1[k]
	}
	for k := range []byte(s2) {  // K 
		result[k+len(s1)] += s2[k]
	}
	return string(result)
}
```

Получение подстроки будет иметь временную и пространственную сложности O(end-start) или O(N-K)
```
func subString(input string, start, end int) string {
	result := make([]byte, end-start)
	for k := start; k < end; k++ {
		result[k-start] = input[k]
	}
	return string(result)
}
```

Давайте разберем следующий пример: дан массив строк, в нем надо отсортировать вначале сами строки, а, затем, и массив целиком
```
func sortStrings(a []string) {
    for k := range a { // N 
        a[k] = sortString(a[k]) // L * log L 
    }
    sortArr(a) // L * N * log N
}
```
цикл по диапазону 'a' имеет линейную зависимость O(N) от количества элементов в срезе 'a'. Предположим, что в качестве 
алгоритма сортировки мы используем сортировку слиянием, которая имеет сложность O(L log L). Следовательно, часть нашего 
алгоритма, которая сортируем строки в массиве будет иметь сложность O(N * L log L). Если мы используем сортировку 
слиянием и для сортировки всего среза целиком, то сложность будет O(L * N log N); L в данном случае - линейная 
зависимость от длинны строки для посимвольного сравнения. Итоговая сложность будет: 
O(N * L * log L + L * N * log N) = O(L * N * (log L + log N))

### Рекурсия

Для одного рекурсивного вызова сложность - O(N), т.к. foo будет вызвана N раз
```
func foo(n int) {
    if n == 1 {
        return
    }
    return foo(n-1)
}
```

Для двух рекурсивных вызовов сложность экспоненциальная - O(2{{< exp >}}n{{< /exp >}}):
```
func foo(n int) {
    if n == 1 { // 1
        return
    }
    return foo(n-1) + foo(n-1)  
}
```

Конец статьи!
